@startuml sequence-wallet-between-fixed

actor User
participant SubscriptionConsumer
participant Wallet
participant Router <<IRouter, ISubscriptionsManager>>
participant Coordinator
participant Billing
participant Inbox
participant Node as InfernetNode

' == Subscription 생성 ==
User -> SubscriptionConsumer: _createComputeSubscription(...)
SubscriptionConsumer -> Router: createSubscription(...)\n[ISubscriptionsManager]
note over Router
 SubscriptionsManager 구현부:
 - s_subscriptions[subId] 저장
 - activeAt/period 초기화
end note
Router --> SubscriptionConsumer: subId

' == 최초 요청 (sendRequest: 선락 + 커밋 생성) ==
SubscriptionConsumer -> Router: sendRequest(containerId, interval,\n redundancy, lazy, paymentToken, paymentAmount,\n wallet, verifier)\n[IRouter]
activate Router
Router -> Router: _markRequestInFlight(wallet, subId,\n redundancy, paymentToken, paymentAmount)\n[internal]
Router -> Wallet: cLock(commitmentSeed, token, amount)
Wallet --> Router: LockedOk

Router -> Coordinator: startRequest(containerId, interval, redundancy,\n lazy, paymentToken, paymentAmount, wallet, verifier)\n[IRouter→ICoordinator]
Coordinator --> Router: Commitment{requestId, commitmentId, subId, interval, timeoutTs, ...}
deactivate Router

Router --> SubscriptionConsumer: Commitment(...)

' == 노드 전달 & Billing 정산 계산 ==
Node -> Coordinator: deliverCompute(subId, interval,\n input, output, proofRef)
Coordinator -> Router: writeInbox(containerId: bytes32, input: bytes calldata,\n\t\t\t output: bytes calldata, proof: bytes calldata)
Router -> Inbox: write(containerId: bytes32,\n\t\t\t input: bytes calldata, output: bytes calldata, proof: bytes calldata)
Coordinator -> Billing: _fulfillAndBill(subId, interval,\n nodeWallet, paymentToken,\n committedAmount, protocolFee, commitmentId)
Billing -> Billing: _calculateFee(subscriptionId: uint32,\n\t\t\t deliveryInterval: uint32, input: bytes, output: bytes,\n\t\t\t proof: bytes, nodeWallet: address)
Billing --> Router: fulfill(subscriptionId: uint32, interval: uint32,\n\t\t\t redundancy: uint16, payments: Payment[], \n\t\t\tinput: bytes, output: bytes, proof: bytes,\n\t\t\t containerId: bytes32, index: uint256)

activate Router
Router --> Router: _pay(subscriptionId: uint64, commitmnetId: uint64, payments Payment[])

' 지급 순서: fee -> node -> unlock
Router -> Wallet: cTransfer(spender=Router, token,\n to=ProtocolFeeRecipient, protocolFeeAmount)
Wallet --> Router: TransferOk
Router -> Wallet: cTransfer(spender=Router, token,\n to=nodeWallet, payAmountToNode)
Wallet --> Router: TransferOk
Router -> Wallet: cUnlock(commitmentId, token, leftoverToUnlock)
Wallet --> Router: UnlockedOk
deactivate Router

Router --> SubscriptionConsumer: rawReceiveCompute(...)
SubscriptionConsumer -> Inbox : read(containerId: bytes32, node: address, index: uint256)

' == 다음 interval 선락 (Coordinator -> Router; 동일 루트) ==
Coordinator -> Router: prepareNextInterval(subId, nextInterval)\n[IRouter]
activate Router
Router -> Router: _markRequestInFlight(wallet, subId,\n paymentToken, nextAmount)\n[internal]
Router -> Wallet: cLock(nextCommitmentSeed, token, nextAmount)
Wallet --> Router: LockedOk

Router -> Coordinator: startRequest(containerId, nextInterval,\n\t\t\t redundancy, lazy, paymentToken,\n\t\t\t nextAmount, wallet, verifier)\n[IRouter→ICoordinator]
Coordinator --> Router: Commitment{requestId, commitmentId, subId, nextInterval, ...}
deactivate Router

@enduml
