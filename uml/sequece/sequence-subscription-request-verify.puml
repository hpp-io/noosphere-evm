@startuml sequence-wallet-between-fixed

    actor User
    participant SubscriptionConsumer
    participant Wallet
    participant Router <<IRouter, ISubscriptionsManager>>
    participant Coordinator
    participant Billing
    participant IVerifier
    participant Node as InfernetNode

    ' == Subscription 생성 ==
    User -> SubscriptionConsumer: _createComputeSubscription(...)
    SubscriptionConsumer -> Router: createSubscription(...)\n[ISubscriptionsManager]
    note over Router
        SubscriptionsManager 구현부:
        - s_subscriptions[subId] 저장
        - activeAt/period 초기화
    end note
    Router --> SubscriptionConsumer: subId

    ' == 최초 요청 (sendRequest: 선락 + 커밋 생성) ==
    SubscriptionConsumer -> Router: sendRequest(containerId, interval,\n\t\t\t redundancy, lazy, paymentToken, paymentAmount,\n\t\t\t wallet, verifier)\n[IRouter]
    activate Router
    Router -> Router: _markRequestInFlight(wallet, subId,\n redundancy, paymentToken, paymentAmount)\n[internal]
    Router -> Wallet: cLock(commitmentSeed, token, amount)
    Wallet --> Router: LockedOk

    Router -> Coordinator: startRequest(containerId, interval, redundancy,\n\t\t\t lazy, paymentToken, paymentAmount, wallet, verifier)\n[IRouter→ICoordinator]
    Coordinator --> Router: Commitment{requestId, commitmentId, subId, interval, timeoutTs, ...}
    deactivate Router

    Router --> SubscriptionConsumer: Commitment(...)

    ' == 노드, 컴퓨팅 결과 전달 & 데이터 즉시 전송 ==
    Node -> Coordinator: deliverCompute(subId, interval,\n input, output, proofRef)
    activate Coordinator

'    note right of Coordinator
'        데이터를 즉시 Router를 통해
''        소비자에게 전달합니다 (Optimistic Fulfillment).
'    end note
'    Coordinator -> Router: fulfill(subId, interval, nodeWallet, output, ...)\n[Data Delivery]
'    activate Router
'    Router -> SubscriptionConsumer: rawReceiveCompute(...)
'    deactivate Router

    alt Subscription has a Verifier
        note right of Coordinator
            Verifier가 설정된 구독이므로
            비동기 검증을 요청하고, 프로토콜 사용료만 결제하고 나머지 결제는 보류합니다.
        end note
        Coordinator -> Router: prepareNodeVerification(subscriptionId: uint32,\n\t\t\t nextInterval: uint32, nodeWallet: address,\n\t\t\t token: address, amountL uint256)
        Router -> Router: _markRequestInFlight(wallet, subId,\n redundancy, paymentToken, paymentAmount)\n[internal]
        Router -> Wallet: cLock(commitmentSeed, token, amount)
        Wallet --> Router: LockedOk
        Coordinator -> IVerifier: requestProofVerification(subId, interval, node, proof, ...)
        Coordinator -> Billing: _fulfillAndBill(subId, interval,\n\t\t\t nodeWallet, paymentToken,\n\t\t\t committedAmount, protocolFee, commitmentId, true)
                       Billing -> Billing: _calculateFee(subscriptionId: uint32, deliveryInterval: uint32,\n\t\t\t input: bytes, output: bytes,\n\t\t\t proof: bytes, nodeWallet: address, true)
                       Billing --> Router: fulfill(subscriptionId: uint32, interval: uint32,\n\t\t\t redundancy: uint16, payments: Payment[], \n\t\t\tinput: bytes, output: bytes, proof: bytes,\n\t\t\t containerId: bytes32, index: uint256)
        Router -> Wallet: cTransfer(spender=Router, token,\n to=ProtocolFeeRecipient, protocolFeeAmount)
            Wallet --> Router: TransferOk
    else No Verifier (Direct Fulfillment)
        note right of Coordinator
            Verifier가 없으므로
            즉시 정산을 진행합니다.
        end note
        ' 정산 로직 시작 (아래 'Proof is valid'의 정산 파트와 동일)
                Coordinator -> Billing: _fulfillAndBill(subId, interval,\n\t\t\t nodeWallet, paymentToken,\n\t\t\t committedAmount, protocolFee, commitmentId, false)
                Billing -> Billing: _calculateFee(subscriptionId: uint32,\n\t\t\t deliveryInterval: uint32, input: bytes,\n\t\t\t output: bytes, proof: bytes,\n\t\t\t nodeWallet: address, false)
                Billing --> Router: fulfill(subscriptionId: uint32, interval: uint32\n\t\t\t, redundancy: uint16, payments: Payment[], \n\t\t\tinput: bytes, output: bytes, proof: bytes,\n\t\t\t containerId: bytes32, index: uint256)
        ' ... (결제 로직 생략) ...
    end
    deactivate Coordinator


    ' == (시간 경과 후) Verifier, 검증 결과 콜백 및 최종 정산 ==
    IVerifier -> Coordinator: finalizeProofVerification(subId, interval, node, valid)
    activate Coordinator

    alt Proof is valid
        note right of Coordinator
            증명이 유효합니다.
            보류된 정산을 시작합니다.
        end note
        ' == Router 경유 최종 지급 ==
        Coordinator -> Billing: _verifyAndBill(subscriptionId: uint32, interval: uint32,\n\t\t\t redundancy: uint16, payments: Payment[], \n\t\t\tinput: bytes, output: bytes, proof: bytes,\n\t\t\t containerId: bytes32, index: uint256)
        Billing -> Billing: _calculateFee(subscriptionId: uint32, deliveryInterval: uint32,\n\t\t\t input: bytes, output: bytes,\n\t\t\t proof: bytes, nodeWallet: address)
        Billing --> Router: _verifyAndBill(subscriptionId: uint32, interval: uint32,\n\t\t\t redundancy: uint16, payments: Payment[], \n\t\t\tinput: bytes, output: bytes, proof: bytes,\n\t\t\t containerId: bytes32, index: uint256)
        activate Router
'        Router -> Billing: _fulfillAndBill(subId, interval, node, ...)\n[internal/IBilling]
        note right of Billing
            Billing은 노드 지불금, Verifier 지불금
            계산하여 반환합니다.
        end note
'        Billing --> Router: payAmountToNode, payAmountToVerifier,\n protocolFeeAmount, leftoverToUnlock

        ' 지급 순서: fee -> verifier -> node -> unlock
        Router -> Wallet: cTransfer(spender=Router, token,\n to=verifierWallet, payAmountToVerifier)
        Wallet --> Router: TransferOk
        Router -> Wallet: cTransfer(spender=Router, token,\n to=nodeWallet, payAmountToNode)
        Wallet --> Router: TransferOk
        Router -> Wallet: cUnlock(commitmentId, token, leftoverToUnlock)
        Wallet --> Router: UnlockedOk
        deactivate Router

    else Proof is invalid
        note right of Coordinator
            증명이 유효하지 않습니다.
            선락된 금액을 사용자에게 환불합니다.
            그리고 node 슬래싱으로 lock된 금액을 사용자에게 전송합니다.
        end note
        Coordinator -> Router: cancelPayment(subId, interval, ...)\n[Refund]
        Coordinator -> Billing: _verifyAndBill(subscriptionId: uint32, interval: uint32,\n\t\t\t redundancy: uint16, , payments: Payment[], \n\t\t\tinput: bytes, output: bytes, proof: bytes,\n\t\t\t containerId: bytes32, index: uint256)
                Billing -> Billing: _calculateFee(subscriptionId: uint32, deliveryInterval: uint32,\n\t\t\t input: bytes, output: bytes,\n\t\t\t proof: bytes, nodeWallet: address)
                Billing --> Router: _verifyAndBill(subscriptionId: uint32, interval: uint32,\n\t\t\t redundancy: uint16, , payments: Payment[], \n\t\t\tinput: bytes, output: bytes, proof: bytes,\n\t\t\t containerId: bytes32, index: uint256)
        activate Router
        Router -> Wallet: cUnlock(commitmentId, token, fullLockedAmount)
        Wallet --> Router: UnlockedOk
        deactivate Router
    end
    deactivate Coordinator


    ' == 다음 interval 선락 (Coordinator -> Router; 동일 루트) ==
    Coordinator -> Router: prepareNextInterval(subId, nextInterval)\n[IRouter]
    activate Router
    Router -> Router: _markRequestInFlight(wallet, subId,\n paymentToken, nextAmount)\n[internal]
    Router -> Wallet: cLock(nextCommitmentSeed, token, nextAmount)
    Wallet --> Router: LockedOk

    Router -> Coordinator: startRequest(containerId, nextInterval,\n\t\t\t redundancy, lazy, paymentToken, nextAmount,\n\t\t\t wallet, verifier)\n[IRouter→ICoordinator]
    Coordinator --> Router: Commitment{requestId, commitmentId, subId, nextInterval, ...}
    deactivate Router

@enduml
