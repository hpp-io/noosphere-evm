@startuml class-diagram

interface "IVerifier" as IVerifier {
    + requestProofVerification(uint32 subscriptionId, uint32 interval, address node, bytes calldata proof, paymentAmount: uint256, paymentToken: address)
    + isSupportedToken(address token) external view returns (bool)
    + fee(address token) external view returns (uint256)
    + verifyProof(bytes): bool
}

class "VerifierInfo" as VerifierInfo {
    + owner: address
    + verifierAddress: address
    + containerId : bytes32
    + wallet : Wallet
    + name: string
    + isActive: bool
}

class "VerifierRegistry" as VerifierRegistry {
    + verifiers: mapping(address => VerifierInfo)
    + verifierByName: mapping(string => VerifierInfo)
    + verifierByContainerId: mapping(bytes32 => VerifierInfo)
    + registerVerifier(verifierAddress: address, containerId: bytes32, wallet: Wallet, name: string memory)
    + updateVerifierInfo(verifierAddress: address, containerId: bytes32, wallet: Wallet, name: string memory)
    + deregisterVerifier(address verifierAddress)
    + setActiveStatus(address verifierAddress, bool isActive)
    + isValidAndActive(address verifierAddress)
    + getVerifierInfo(address verifierAddress)
    <<event>> VerifierRegistered(address indexed verifierAddress, address indexed owner, string name);
    <<event>> VerifierUpdated(address indexed verifierAddress);
    <<event>> VerifierDeregistered(address indexed verifierAddress);
    <<event>> VerifierActivityChanged(address indexed verifierAddress, bool isActive);
}

class "Subscription" as Subscription << (S,orchid) struct >> {
    + owner: address
    + activeAt: uint32
    + period: uint32
    + frequency: uint32
    + redundancy: uint16
    + containerId: bytes32
    + lazy: bool
    + verifier: address payable
    + paymentAmount: uint256
    + paymentToken: address
    + wallet: address payable
}

class "ProofRequest" as ProofRequest << (S,orchid) struct >> {
    + expiry: uint32
    + nodeWallet: Wallet
    + consumerEscrowed: uint256
}

class "TickConfig" as TickConfig  << struct >> {
    + interval: uint32
    + tickBounty: uint256
    + paymentToken: address
    + bountyFromProtocolFee : bool
}

class InboxItem <<struct>> {
    + timestamp : uint32
    + subscriptionId : uint32
    + interval : uint32
    + input : bytes
    + output : bytes
    + proof : bytes
}

interface "IInbox" as IInbox {
    + write(containerId: bytes32, input: bytes calldata, output: bytes calldata, proof: bytes calldata) : uint256
    + read(containerId: bytes32, node: address, index: uint256): InboxItem
}

class "Inbox" as Inbox {
    + items : mapping(address: containerId => InboxItem[]))
    .. IInbox ..
    + write(containerId: bytes32, input: bytes calldata, output: bytes calldata, proof: bytes calldata) : uint256
    + read(containerId: bytes32, node: address, index: uint256)
}

abstract class Ownable

abstract class Routable {
    - i_router: IOwnableFunctionsRouter <<immutable>>
    + constructor(address router)
    # _getRouter(): IOwnableFunctionsRouter
    # <<modifier>> onlyRouter()
    # <<modifier>> onlyRouterOwner()
}

class Wallet {
    - _owner: address
    - lockedBalance: mapping(address => uint256)
    - allowance: mapping(address => mapping(address => uint256))
    + <<constructor>>(registry: address, initialOwner: address)
    # _getUnlockedBalance(address token): uint256
    # _transferToken(address token, address to, uint256 amount)
    + withdraw(address token, uint256 amount)
    + approve(address spender, address token, uint256 amount)
    + cTransfer(address spender, address token, address to, uint256 amount)
    + cLock(address spender, address token, uint256 amount)
    + cUnlock(address spender, address token, uint256 amount)
    + receive()
    + <<event>> Withdrawl(address: address, amount: uint256)
    + <<event>> Approval(spender: address indexed, token: address, amount: uint256)
    + <<event>> Escrow(spender: address indexed, token: address, amount: uint256, locked: bool)
    + <<event>> Transfer(spender: address indexed, token: address, to: address indexed, amount: uint256)
}

class WalletFactory {
    - _wallets: mapping(address => bool)
    - _router: Router
    + <<constructor>>(registry: address)
    + isValidWallet(owner: address): bool
    + createWallet(): address
    + <<event>> WalletCreated(owner: address, wallet: address)
}

interface ISubscriptionsManager {
    + getSubscription(subscriptionId: uint32): Subscription <<view>>
    + getSubscriptionInterval(activeAt: uint32, period: uint32): uint32 <<view>>
    + createSubscription(containerId: string, frequency: uint32, period: uint32, redundancy: uint16, \n\t\t\tlazy: bool, paymentToken: address, paymentAmount: uint256, wallet: address, verifier: address): uint32
    + cancelSubscription(subscriptionId: uint32)
    + pendingRequestExists(subscriptionId: uint32)
    + timeoutRequests(requestsToTimeoutByCommitment: Commitment)
}

abstract class "SubscriptionsManager" as SubscriptionsManager {
    .. State ..
    # s_subscriptions: mapping(uint32 => Subscription)
    # mapping(bytes32 requestId => bytes32 commitmentHash) internal s_requestCommitments;

    .. ISubscriptionsManager Implementation ..
    + getSubscription(subscriptionId: uint32): Subscription <<view>>
    + getSubscriptionInterval(activeAt: uint32, period: uint32): uint32 <<view>>
    + createSubscription(containerId: string, frequency: uint32, period: uint32, redundancy: uint16, \n\t\t\tlazy: bool, paymentToken: address, paymentAmount: uint256, wallet: address, verifier: address): uint32
    + cancelSubscription(subscriptionId: uint32)
    + pendingRequestExists(subscriptionId: uint32) : requestId[]
    + timeoutRequests(requestsToTimeoutByCommitment: Commitment)
    ..
    # _markRequestInFlight(wallet: address, uint64 subscriptionId, redundancy: uint16, paymentToken: address, paymentAmount: uint256)
    # _pay(subscriptionId: uint64, commitmnetId: uint64, payments Payment[])
    # _callback(subscriptionId: uint32, interval: uint32, redundancy: uint16, node: address, \n\t\t\tinput: bytes, output: bytes, proof: bytes, containerId: bytes32, index: uint256)
    # _cancelSubscriptionHelper(subscriptionId: uint32)
    # _timeoutPrepareNextIntervalRequests(subscriptionId: uint32)
}

class ContractProposalSet <<struct>> {
    - bytes32[] ids;
    - address[] to;
}

interface IRouter {
    + sendRequest(subscriptionId: uint32, interval: uint32, redundancy: uint16, node: address, \n\t\t\tinput: bytes, output: bytes, proof: bytes, containerId: bytes32, index: uint256)
    + fulfill(subscriptionId: uint32, interval: uint32, redundancy: uint16, payments: Payment[], \n\t\t\tinput: bytes, output: bytes, proof: bytes, containerId: bytes32, index: uint256)
    + prepareNextInterval(subscriptionId: uint32, nextInterval: uint32, payments: Payment[])
    + writeInbox(containerId: bytes32, input: bytes calldata, output: bytes calldata, proof: bytes calldata)
    + getContractById(bytes32 id)
    + proposeContractsUpdate(proposalSetIds: bytes32[], proposalSetAddresses : address[])
    + updateContracts()
    + pause()
    + unpause()
    + pendingRequestExists(subscriptionId: uint32)
    + cancelRequests(subscriptionId: uint32)
    + getAllowListId()
    + setAllowListId()
    + isValidWallet(owner: address): bool
    + createWallet(): address
}

class Router {
    - s_route: mapping(bytes32 => address)
    - s_proposedContractSet: ContractProposalSet
    - s_allowListId : bytes32
    - s_inbox: address
    - s_wallet_factory: WalletFactory

    .. IRouter ..
    + sendRequest(containerId: string, interval: uint32,  redundancy: uint16, \n\t\t\tlazy: bool, paymentToken: address, paymentAmount: uint256, wallet: address, verifier: address): Commitment
    + fulfill(subscriptionId: uint32, interval: uint32, redundancy: uint16, payments: Payment[], \n\t\t\tinput: bytes, output: bytes, proof: bytes, containerId: bytes32, index: uint256)
    + prepareNextInterval(subscriptionId: uint32, nextInterval: uint32)
    + writeInbox(containerId: bytes32, input: bytes calldata, output: bytes calldata, proof: bytes calldata)
    + prepareNodeVerification(subscriptionId: uint32, nextInterval: uint32, nodeWallet: address, token: address, amountL uint256)
    + getContractById(bytes32 id)
    + getProposedContractById(bytes32 id)
    + proposeContractsUpdate(proposalSetIds: bytes32[], proposalSetAddresses : address[])
    + updateContracts()
    + pause()
    + unpause()
    + getAllowListId()
    + setAllowListId()
    ..
}

interface ICoordinator {
    + startRequest(containerId: string, interval: uint32,  redundancy: uint16, \n\t\t\tlazy: bool, paymentToken: address, paymentAmount: uint256, wallet: address, verifier: address): Commitment
    + cancelRequests((subscriptionId)
    + deliverCompute(requestId: uint32, subscriptionId: uint32, deliveryInterval: uint32, input: bytes, output: bytes, proof: bytes, nodeWallet: address)
    + finalizeProofVerification(subscriptionId: uint32, interval: uint32, node: address, valid: bool)
    + prepareNextInterval(subscriptionId: uint32, nextInterval: uint32)
}

class Coordinator {
    + nodeResponded: mapping(hash(subscriptionId, interval, caller) => bool)
    + redundancyCount: mapping(hash(subscriptionId, interval) => uint16)
    + proofRequests: mapping(bytes32 => ProofRequest)
    - verifierRegistry : VerifierRegistry immutable
    + <<constructor>>(router: address, verifierRegistry : address, config: Config)
    .. ICoordinator ..
    + startRequest(subscriptionId: string, interval: uint32,  redundancy: uint16, \n\t\t\tlazy: bool, paymentToken: address, paymentAmount: uint256, wallet: address, verifier: address): Commitment
    + cancelRequests((subscriptionId)
    + deliverCompute(subscriptionId: uint32, deliveryInterval: uint32, input: bytes, output: bytes, proof: bytes, nodeWallet: address)
    + finalizeProofVerification(subscriptionId: uint32, interval: uint32, node: address, valid: bool)
    ..
}

class BillingConfig <<struct >> {
    - uint32 requestTimeoutSeconds;
    - uint256 protocolFee;
    - uint32 gasOverheadBeforeCallback;
    - uint32 gasOverheadAfterCallback;
    - uint32 minimumEstimateGasPriceWei;
    - uint256 tickNodeFee;
}

class Commitment <<struct >> {
    + bytes32 requestId
    + coordinator: address
    + subscriptionId: uint32
    + containerId: bytes32
    + lazy: bool
    + verifier: address payable
    + paymentAmount: uint256
    + paymentToken: address
    + timeoutTimestamp: uint32
    + redundancy: uint16
    + interval : uint32
}

class "Payment" as Payment  << struct >> {
    + recipient: address
    + paymentToken: amount
    + paymentAmount: uint256
}

interface IBilling {
    + getConfig()
    + updateConfig(config: BillingConfig)
    + getProtocolFee(): uint72
    + estimateCost()
    + deleteCommitment(bytes32 requestId)
}

abstract class Billing {
    - router: address
    - s_config: BillingConfig
    - s_requestCommitments: mapping(hash(subscriptionId, interval) => bytes32)
    .. IBilling ..
    + getConfig()
    + updateConfig(config: BillingConfig)
    + getProtocolFee(): uint72
    + estimateCost()
    + deleteCommitment(bytes32 requestId)
    ..
    # _calculateFee(subscriptionId: uint32, deliveryInterval: uint32, input: bytes, output: bytes, proof: bytes, nodeWallet: address) : Payment[]
    # _startBilling(containerId: string, interval: uint32,  redundancy: uint16, \n\t\t\tlazy: bool, paymentToken: address, paymentAmount: uint256, wallet: address, verifier: address): Commitment
    # _fulfillAndBill(subscriptionId: uint32, interval: uint32, redundancy: uint16, payments: Payment[], \n\t\t\tinput: bytes, output: bytes, proof: bytes, containerId: bytes32, index: uint256, requestVerify: bool)
    # _verifyAndBill(subscriptionId: uint32, interval: uint32, redundancy: uint16, , payments: Payment[], \n\t\t\tinput: bytes, output: bytes, proof: bytes, containerId: bytes32, index: uint256)
    # _calculateNextTickFee(subscriptionId: uint32, deliveryInterval: uint32, nodeWallet: address) : Payment[]
}

abstract class EIP712 {
    # _hashTypedData(structHash: bytes32) : bytes32
    # _domainNameAndVersion(): (string, string)
    # _domainNameAndVersionMayChange(): bool
}

class ECDSA <<library>> {
    + recover(digest: bytes32, v: uint8, r: bytes32, s: bytes32): address
}

class Delegator {
    + getSigner(): address
}

class EIP712Coordinator {
    + EIP712_VERSION: string = "1"
    + EIP712_NAME: string = "InfernetCoordinator"
    - EIP712_SUBSCRIPTION_TYPEHASH: bytes32
    - EIP712_DELEGATE_SUBSCRIPTION_TYPEHASH: bytes32
    + maxSubscriberNonce: mapping(address => uint32)
    + delegateCreatedIds: mapping(bytes32 => uint32)
    ...
    + createSubscriptionDelegatee(nonce: uint32, expiry: uint32, sub: Subscription, v: uint8, r: bytes32, s: bytes32): uint32
    + deliverComputeDelegatee(nonce: uint32, expiry: uint32, sub: Subscription, v: uint8, r: bytes32, s: bytes32, \n\t\t\tdeliveryInterval: uint32, input: bytes, output: bytes, proof: bytes, payments: Payment[])
    + <<error>> SignerMismatch()
    + <<error>> SignatureExpired()
}

' Consumer base classes
abstract class BaseConsumer {
'    - COORDINATOR: Coordinator <<immutable>>
'    - INBOX: Inbox <<immutable>>
    - router: Router <<immutable>>
    + <<constructor>>(router: address)
    # _receiveCompute(subscriptionId: uint32, interval: uint32, redundancy: uint16, node: address, \n\t\t\tinput: bytes, output: bytes, proof: bytes, containerId: bytes32, index: uint256) <<virtual>>
    + getContainerInputs(subscriptionId: uint32, interval: uint32, timestamp: uint32, caller: address): bytes <<view, virtual>>
    + rawReceiveCompute(subscriptionId: uint32, interval: uint32, redundancy: uint16, node: address, \n\t\t\tinput: bytes, output: bytes, proof: bytes, containerId: bytes32, index: uint256)
}
'
' ===== CallbackConsumer =====
abstract class CallbackConsumer {
    - subscriptionInputs: mapping(uint32 => bytes)
    + <<constructor>>(router: address)
    # _requestCompute(containerId: string, inputs: bytes, redundancy: uint16, paymentToken: address, \n\t\t\tpaymentAmount: uint256, wallet: address, verifier: address): uint32
    + getContainerInputs(subscriptionId: uint32, interval: uint32, timestamp: uint32, caller: address): bytes <<view, override>>
}

abstract class SubscriptionConsumer {
    + <<constructor>>(router: address)
    # _createComputeSubscription(containerId: string, frequency: uint32, period: uint32, redundancy: uint16, \n\t\tlazy: bool, paymentToken: address, paymentAmount: uint256, wallet: address, verifier: address): uint32
    # _cancelComputeSubscription(subscriptionId: uint32)
}

' Relationships
Wallet --|> Ownable
Wallet --|> Routable

WalletFactory ..> Wallet    : <<create>>
WalletFactory o-- Wallet: tracks (wallets mapping)
WalletFactory --> Router : ctor

SubscriptionsManager ..|> ISubscriptionsManager : implements
SubscriptionsManager *-- Subscription: stores

Router ..|> IRouter : implements
Router --|> SubscriptionsManager : extends
Router --> WalletFactory : uses
Router --> Inbox : uses
Router --> ContractProposalSet : uses
Router --> Wallet : payments/escrow
Router ..> ICoordinator : uses(via s_route)

Inbox ..|> IInbox: implements
Verifier ..|> IVerifier: implements
Inbox *-- InboxItem: stores

Coordinator ..|> ICoordinator: implements
Coordinator --|> Billing : extends
Coordinator *-- ProofRequest: stores
Billing --> TickConfig : uses

Billing *-- Commitment: stores
Billing ..|> IBilling : implements
Billing --> Config : uses
Billing --> Payment : uses
Billing --> IRouter : uses

VerifierRegistry *-- VerifierInfo: stores
Coordinator --> VerifierRegistry : uses

EIP712Coordinator --|> Coordinator
EIP712Coordinator --|> EIP712
EIP712Coordinator ..> ECDSA: recover()
EIP712Coordinator ..> Delegator: getSigner()

BaseConsumer --> Router : ctor (fetches COORDINATOR address)

CallbackConsumer --|> BaseConsumer
CallbackConsumer --> Router : uses (createSubscription)

SubscriptionConsumer --|> BaseConsumer
SubscriptionConsumer --> Router : uses (createSubscription, cancelSubscription)

@enduml
