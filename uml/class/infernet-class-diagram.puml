@startuml class-diagram

skinparam classAttributeIconSize 0
skinparam backgroundColor white
skinparam classBackgroundColor WhiteSmoke
skinparam classBorderColor Black
skinparam arrowColor Black
skinparam linetype ortho

interface "IInbox" as IInbox {
    + write(bytes32, address, uint256, bytes, bytes, bytes): InboxItem
    + read(bytes32, address, uint256): InboxItem
    ...
}

interface "IVerifier" as IVerifier {
    + verifyProof(bytes): bool
    ...
}

' ===== Structs =====
class "Subscription" as Subscription <<struct>> {
  + owner: address
  + activeAt: uint32
  + period: uint32
  + frequency: uint32
  + redundancy: uint16
  + containerId: bytes32
  + lazy: bool
  + verifier: address payable
  + paymentAmount: uint256
  + paymentToken: address
  + wallet: address payable
}

class "ProofRequest" as ProofRequest <<struct>> {
  + expiry: uint32
  + nodeWallet: Wallet
  + consumerEscrowed: uint256
}


class InboxItem <<struct>> {
    +timestamp : uint32
    +subscriptionId : uint32
    +interval : uint32
    +input : bytes
    +output : bytes
    +proof : bytes
}


' ===== Class =====
class "Registry" as Registry {
    - _protocol: address
    - _coordinator: address
    - _inbox: address
    - _wallet: address
    - _ensRegistry: address
    - _ensResolver: address
    + <<constructor>>(protocol: address, coordinator: address, inbox: address, wallet: address, ensRegistry: address, ensResolver: address)
    + protocol(): address
    + coordinator(): address
    + inbox(): address
    + wallet(): address
    + ensRegistry(): address
    + ensResolver(): address
    ...
}

class "Inbox" as Inbox implements IInbox {
    - items: mapping(bytes32 => mapping(address => InboxItem[]))
    + <<constructor>>(registry: Registry)
    + <<event>> NewInboxItem(containerId: bytes32, node: address, index: uint256)
    --
    # _write(containerId: bytes32, node: address, subscriptionId: uint32, interval: uint32 input: bytes, output: bytes, proof: bytes): uint256
    + write(containerId: bytes32, input: bytes, output: bytes, proof: bytes): uint256
    + writeViaCoordinator(containerId: bytes32, node: address, subscriptionId: uint32,\n\t\t\t interval: uint32, input: bytes, output: bytes, proof: bytes): uint256 <<onlyCoordinator>>
    + read(containerId: bytes32, node: address, index: uint256): InboxItem
}

' Payment system
class "Fee" as Fee {
    - FEE : uint16
    --
    + <<constructor>>(feeRecipient: address, fee: uint16)
    + updateFee(newFee: uint16)
    + FEE_RECIPIENT() : address
}

abstract class Ownable
abstract class Coordinated {
    +{static} COORDINATOR() : address
    +onlyCoordinator()
}

class "Wallet" as Wallet {
    - _owner : address
    - lockedBalance : mapping(address => uint256)
    - allowance : mapping(address => mapping(address => uint256))
    ....
    + <<constructor>>(registry: address, initialOwner: address)
    # _getUnlockedBalance(address token): uint256
    # _transferToken(address token, address to, uint256 amount)
    + withdraw(address token, uint256 amount)
    + approve(address spender, address token, uint256 amount)
    + cTransfer(address spender, address token, address to, uint256 amount)
    + cLock(address spender, address token, uint256 amount)
    + cUnlock(address spender, address token, uint256 amount)
    + receive()
    + <<event>> Withdrawl(address: address, amount: uint256)
    + <<event>> Approval(spender: address indexed, token: address, amount: uint256)
    + <<event>> Escrow(spender: address indexed, token: address, amount: uint256, locked: bool)
    + <<event>> Transfer(spender: address indexed, token: address, to: address indexed, amount: uint256)
}

class "WalletFactory" as WalletFactory {
    - _wallets: mapping(address => address)
    - _registry: Registry
    ....
    + <<constructor>>(registry: address)
    + isValidWallet(owner: address): bool
    + createWallet(): address
    + <<event>> WalletCreated(owner: address, wallet: address)
}

class "Coordinator" as Coordinator {
    - FEE : Fee <<immutable>>
    - INBOX : Inbox <<immutable>>
    - WALLET_FACTORY : WalletFactory <<immutable>>
    + id : uint32
    + nodeResponded : mapping(bytes32: hash(subscriptionId, interval, caller) => bool)
    + redundancyCount : mapping(bytes32: hash(subscriptionId, interval) => uint16)
    + proofRequests : mapping(bytes32: hash(subscriptionId, interval, caller) => ProofRequest)
    + subscriptions : mapping(uint32: subscriptionID => Subscription)

    + <<constructor>>(registry: Registry)
    # _calculateFee(amount: uint256, fee: uint16) : uint256
    + getSubscription(subscriptionId: uint32) : Subscription <<view>>
    + getSubscriptionInterval(activeAt: uint32, period: uint32) : uint32 <<view>>
    + createSubscription(containerId: string, frequency: uint32, period: uint32, redundancy: uint16,\n\t\t\tlazy: bool, paymentToken: address, paymentAmount: uint256, wallet: address, verifier: address) : uint32
    + cancelSubscription(subscriptionId: uint32)
    + deliverCompute(subscriptionId: uint32, deliveryInterval: uint32, input: bytes, output: bytes, proof: bytes, nodeWallet: address)
    + finalizeProofVerification(subscriptionId: uint32, interval: uint32, node: address, valid: bool)

    ..errors..
    + <<error>> InvalidWallet()
    + <<error>> IntervalMismatch()
    + <<error>> IntervalCompleted()
    + <<error>> UnauthorizedVerifier()
    + <<error>> NodeRespondedAlready()
    + <<error>> SubscriptionNotFound()
    + <<error>> ProofRequestNotFound()
    + <<error>> NotSubscriptionOwner()
    + <<error>> SubscriptionCompleted()
    + <<error>> SubscriptionNotActive()
    + <<error>> UnsupportedVerifierToken()
}

abstract class EIP712 {
    # _hashTypedData(structHash: bytes32) : bytes32
    # _domainNameAndVersion() : (string,string)
    # _domainNameAndVersionMayChange() : bool
}

class ECDSA <<library>> {
    + recover(digest: bytes32, v: uint8, r: bytes32, s: bytes32) : address
}
class Delegator {
      + getSigner() : address
}

class "EIP712Coordinator" as EIP712Coordinator {
    + EIP712_VERSION : string = "1"
    + EIP712_NAME    : string = "InfernetCoordinator"
    - EIP712_SUBSCRIPTION_TYPEHASH : bytes32
    - EIP712_DELEGATE_SUBSCRIPTION_TYPEHASH : bytes32
    + maxSubscriberNonce : mapping(address => uint32)
    + delegateCreatedIds : mapping(bytes32 => uint32) : hash(sub.owner, nonce) -> subid
    ....
    + createSubscriptionDelegatee(nonce: uint32, expiry: uint32, sub: Subscription, v: uint8, r: bytes32, s: bytes32) : uint32
    + deliverComputeDelegatee(nonce: uint32, expiry: uint32, sub: Subscription, v: uint8, r: bytes32, s: bytes32,\n\t\t\tdeliveryInterval: uint32, input: bytes, output: bytes, proof: bytes, nodeWallet: address)

    + <<error>> SignerMismatch()
    + <<error>> SignatureExpired()
}

' Consumer base classes
abstract class "BaseConsumer" as BaseConsumer {
  - COORDINATOR : Coordinator <<immutable>>
  - INBOX : Inbox <<immutable>>
  ....
  + <<constructor>>(registry: address)
  # _receiveCompute(subscriptionId: uint32, interval: uint32, redundancy: uint16, node: address,\n\t\t\tinput: bytes, output: bytes, proof: bytes, containerId: bytes32, index: uint256) <<virtual>>
  + getContainerInputs(subscriptionId: uint32, interval: uint32, timestamp: uint32,caller: address) : bytes <<view, virtual>>
  + rawReceiveCompute(subscriptionId: uint32, interval: uint32, redundancy: uint16, node: address,\n\t\t\tinput: bytes, output: bytes, proof: bytes, containerId: bytes32, index: uint256)

}

' ===== CallbackConsumer =====
abstract class "CallbackConsumer" as CallbackConsumer {
  - subscriptionInputs : mapping(uint32 => bytes)
  ....
  + <<constructor>>(registry: address)
  # _requestCompute(containerId: string, inputs: bytes,redundancy: uint16, paymentToken: address,\n\t\t\tpaymentAmount: uint256, wallet: address, verifier: address) : uint32
  + getContainerInputs(subscriptionId: uint32, interval: uint32,timestamp: uint32, caller: address) : bytes <<view, override>>
}

abstract class "SubscriptionConsumer" as SubscriptionConsumer {
  + <<constructor>>(registry: address)
  # _createComputeSubscription(containerId: string, frequency: uint32, period: uint32, redundancy: uint16,\n\t\tlazy: bool, paymentToken: address,paymentAmount: uint256, wallet: address, verifier: address) : uint32
  # _cancelComputeSubscription(subscriptionId: uint32)
}

' Relationships
' ------------------------
' (1) 생성자 주입 (ctor)
' ------------------------
Coordinated --> Registry : ctor (holds ref)
WalletFactory --> Registry : ctor
Coordinator --> Registry : ctor (fetch addresses)
EIP712Coordinator --> Registry : ctor (passes to super)
BaseConsumer --> Registry: ctor

' Wallet은 Coordinated를 통해 간접 주입
Wallet --|> Coordinated
Wallet --> Registry : references (via parent ctor)

' ------------------------
' (2) 런타임 사용 (uses)
' ------------------------
Inbox --> Registry : uses (onlyCoordinator path)
Coordinator --> Registry : uses (FEE/INBOX/WALLET_FACTORY resolved at ctor, then used)

Wallet --|> Ownable
Wallet --|> Coordinated

WalletFactory ..> Wallet    : <<create>>
WalletFactory o-- Wallet    : tracks (wallets mapping)

Inbox --|> Coordinated
Inbox *-- InboxItem : stores

Fee --|> Ownable

Coordinator --|> ReentrancyGuard
Coordinator *-- Subscription : stores
Coordinator *-- ProofRequest : stores
Coordinator --> Fee           : uses
Coordinator --> Inbox         : uses
Coordinator --> WalletFactory : uses
Coordinator --> Wallet        : payments/escrow
Coordinator --> BaseConsumer  : callback
Coordinator --> IVerifier     : proof verification

EIP712Coordinator --|> Coordinator
EIP712Coordinator --|> EIP712
EIP712Coordinator ..> ECDSA     : recover()
EIP712Coordinator ..> Delegator : getSigner()

BaseConsumer --> Coordinator : ctor (fetches COORDINATOR address)
BaseConsumer --> Inbox       : ctor (fetches INBOX address)

CallbackConsumer --|> BaseConsumer
CallbackConsumer --> Coordinator : uses (createSubscription)

SubscriptionConsumer --|> BaseConsumer
SubscriptionConsumer --> Coordinator : uses (createSubscription, cancelSubscription)


@enduml
