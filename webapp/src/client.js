// Use the 'dotenv' package to load environment variables from a .env file.
// To ensure the path is correct regardless of where the script is run from, resolve it from the current directory.
const path = require('path');
require('dotenv').config({ path: path.resolve(__dirname, '../../.env') });

const ethers = require('ethers');

// --- Path Resolution ---
// Define the project's root directory to resolve all paths correctly.
const projectRoot = path.resolve(__dirname, '../..');

// Import contract artifacts generated by Foundry using the correct paths.
const TransientClientArtifact = require(path.join(projectRoot, 'out/MyTransientClient.sol/MyTransientClient.json'));
const RouterArtifact = require(path.join(projectRoot, 'out/Router.sol/Router.json'));
const WalletFactoryArtifact = require(path.join(projectRoot, 'out/WalletFactory.sol/WalletFactory.json'));
const WalletArtifact = require(path.join(projectRoot, 'out/Wallet.sol/Wallet.json'));

// Dynamically load a contract address from the latest deployment.
function getLatestDeploymentAddress(contractName) {
    try {
        // Load the broadcast file which contains the results of the last deployment.
        const chainId = 31337; // Assuming local Anvil chain
        const broadcastPath = path.join(projectRoot, `broadcast/DeployTest.sol/${chainId}/run-latest.json`);
        const broadcast = require(broadcastPath);
        // Find the transaction for the contract deployment.
        const deployment = broadcast.transactions.find(
            (tx) => tx.transactionType === 'CREATE' && tx.contractName === contractName
        );
        return deployment?.contractAddress;
    } catch (e) {
        console.error(`Could not find or parse broadcast file for chain 31337.`, e);
        return undefined;
    }
}

function requestIdPacked(subscriptionId, interval) {
    const packedData = ethers.solidityPacked(
        ['uint64', 'uint32'],
        [subscriptionId, interval]
    );
    const rid = ethers.keccak256(packedData);
    return rid;
}


async function main() {
    // Load RPC_URL and PRIVATE_KEY from the .env file.
    const rpcUrl = process.env.RPC_URL;

    // Get contract addresses from the latest deployment run.
    const CLIENT_ADDRESS = getLatestDeploymentAddress('MyTransientClient');
    const ROUTER_ADDRESS = getLatestDeploymentAddress('Router');

    if (!CLIENT_ADDRESS || !ROUTER_ADDRESS) {
        console.error("Error: Could not find MyTransientClient or Router address in run-latest.json. Please deploy contracts first.");
        process.exit(1);
    }

    // --- Pre-flight Check: Verify contract code exists at the address ---
    const provider = new ethers.JsonRpcProvider(rpcUrl);

    if (!rpcUrl) {
        console.error("Error: RPC_URL is not set in the .env file.");
        process.exit(1);
    }
    const clientCode = await provider.getCode(CLIENT_ADDRESS);
    if (clientCode === '0x') {
        console.error(`\n‚ùå Error: No contract code found at MyTransientClient address (${CLIENT_ADDRESS}).`);
        console.error("   Please make sure you have run 'npm run deploy' successfully before running the client.");
        process.exit(1);
    }

    // Set up the provider and signer.
    // For E2E tests, we dynamically get the first signer provided by the Anvil node.
    let signer = await provider.getSigner(0);
    console.log(`Using signer address: ${signer.address}`);

    // Create contract instances.
    let clientContract = new ethers.Contract(CLIENT_ADDRESS, TransientClientArtifact.abi, signer);
    let routerContract = new ethers.Contract(ROUTER_ADDRESS, RouterArtifact.abi, signer);

    // --- VIEW FUNCTION CALL TO VERIFY CONNECTION ---
    try {
        let version = await clientContract.typeAndVersion();
        console.log(`\n‚úÖ Successfully connected to client contract.`);
        console.log(`   Contract: MyTransientClient`);
        console.log(`   Address:  ${await clientContract.getAddress()}`);
        console.log(`   Version:  ${version}`);

        version = await routerContract.typeAndVersion();
        console.log(`\n‚úÖ Successfully connected to client contract.`);
        console.log(`   Contract: Router`);
        console.log(`   Address:  ${await routerContract.getAddress()}`);
        console.log(`   Version:  ${version}`);

    } catch (e) {
        console.error("\n‚ùå Could not connect to the Client contract. Please check the address, ABI, and network.");
        console.error(e);
        process.exit(1);
    }

    try {
        // --- Initialize nonce using 'pending' to include mempool/pending txs ---
        let nonce = await provider.getTransactionCount(signer.address, 'pending');
        console.log(`Starting nonce (pending): ${nonce}`);

        // --- 0. Create a new Wallet via the WalletFactory ---
        console.log("\n0Ô∏è‚É£  Creating a new wallet for the subscription...");
        const walletFactoryAddress = await routerContract.getWalletFactory();
        if (walletFactoryAddress === ethers.ZeroAddress) {
            throw new Error("WalletFactory address is not set on the Router.");
        }
        const walletFactoryContract = new ethers.Contract(walletFactoryAddress, WalletFactoryArtifact.abi, signer);
        console.log(`   WalletFactory found at: ${walletFactoryAddress}`);

        // Create the wallet
        const createWalletTx = await walletFactoryContract.createWallet.send(signer.address, { nonce });
        nonce++; // Manually increment nonce for the next transaction
        const createWalletReceipt = await createWalletTx.wait(1);

        // Find the event to get the new wallet's address
        const walletCreatedEvents = await walletFactoryContract.queryFilter("WalletCreated", createWalletReceipt.blockNumber, createWalletReceipt.blockNumber);
        const ourWalletEvent = walletCreatedEvents.find(e => e.transactionHash === createWalletTx.hash);
        if (!ourWalletEvent) {
            throw new Error("Could not find 'WalletCreated' event.");
        }
        const newWalletAddress = ourWalletEvent.args.walletAddress;
        console.log(`   ‚úÖ New Wallet Created! Address: ${newWalletAddress}`);

        // Fund the newly created wallet with some ETH for fees
        console.log(`   Funding the new wallet with 0.1 ETH...`);
        const fundTx = await signer.sendTransaction({
            to: newWalletAddress,
            value: ethers.parseEther("0.1"),
            nonce // Use the incremented nonce
        });
        nonce++; // Increment nonce again for the next transaction
        await fundTx.wait(1);
        console.log(`   ‚úÖ Wallet funded. Tx: ${fundTx.hash}`);

        // Approve the Client contract (spender) to spend funds from the new wallet
        console.log(`   Approving the Client contract to spend from the new wallet...`);
        const walletContract = new ethers.Contract(newWalletAddress, WalletArtifact.abi, signer);
        // We approve the client for a very large amount (practically infinite) for the native token (address(0))
        const approveTx = await walletContract.approve.send(CLIENT_ADDRESS, ethers.ZeroAddress, ethers.MaxUint256, {
            nonce // Use the incremented nonce
        });
        nonce++; // Increment nonce again for the next transaction
        await approveTx.wait(1);
        console.log(`   ‚úÖ Client contract approved. Tx: ${approveTx.hash}`);

        // --- 1. Create a new compute subscription ---

        const coordinatorId = ethers.encodeBytes32String("Coordinator_v1.0.0");
        console.log(coordinatorId);
        const coordinatorAddress = await routerContract.getContractById(coordinatorId);
        console.log(`   Coordinator Address for routeId "Coordinator_v1.0.0" : ${coordinatorAddress}`);

        console.log("\n1Ô∏è‚É£  Sending transaction to create a new compute subscription...");
        const subscriptionParams = {
            containerId: "my-container-id",
            redundancy: 1,
            useDeliveryInbox: false,
            feeToken: ethers.ZeroAddress, // Native ETH
            feeAmount: ethers.parseEther("0.0001"),
            wallet: newWalletAddress, // The wallet that will pay for the compute
            verifier: ethers.ZeroAddress, // No verifier in this example
            routeId: coordinatorId // Example routeId
        };

        // Use the pending-based nonce
        const createSubTx = await clientContract.createSubscription.send(
            subscriptionParams.containerId,
            subscriptionParams.redundancy,
            subscriptionParams.useDeliveryInbox,
            subscriptionParams.feeToken,
            subscriptionParams.feeAmount,
            subscriptionParams.wallet,
            subscriptionParams.verifier,
            subscriptionParams.routeId,
            { nonce } // explicit pending-based nonce
        );

        console.log(`   Transaction sent! Hash: ${createSubTx.hash}`);
        // Increment nonce for the next transaction before we send it.
        nonce++;
        const createSubReceipt = await createSubTx.wait(1);

        if (createSubReceipt.status !== 1) {
            console.error(`\n‚ùå Subscription creation failed!`);
            process.exit(1);
        }

        // --- Find the SubscriptionCreated Event ---
        // Fetch all SubscriptionCreated events from the transaction's block...
        const events = await routerContract.queryFilter("SubscriptionCreated", createSubReceipt.blockNumber, createSubReceipt.blockNumber);
        // ...and then find the specific event from our transaction.
        const subCreatedEvent = events.find(e => e.transactionHash === createSubTx.hash);

        if (!subCreatedEvent) {
            throw new Error("Could not find 'SubscriptionCreated' event.");
        }

        const { subscriptionId } = subCreatedEvent.args;
        console.log(`   ‚úÖ New Subscription Created! ID: ${subscriptionId.toString()}`);


        // --- 2. Request a compute job for the new subscription ---
        console.log("\n2Ô∏è‚É£  Sending transaction to request a compute job...");
        const computeInputs = "0x1234"; // Example input data

        // Use the incremented nonce (we already incremented after create)
        console.log(`   Using nonce for requestCompute: ${nonce}`);
        const requestTx = await clientContract.requestCompute.send(subscriptionId, computeInputs, {
            nonce
        });
        // increment nonce in case you want to send more txs later
        nonce++;

        const requestReceipt = await requestTx.wait(1);

        if (requestReceipt.status !== 1) {
            throw new Error("Compute request transaction failed!")
        }

        // To get the requestId, we need to parse the logs from the ROUTER contract
        const requestStartEvents = await routerContract.queryFilter("RequestStart", requestReceipt.blockNumber, requestReceipt.blockNumber);
        const ourRequestEvent = requestStartEvents.find(e => e.transactionHash === requestTx.hash);

        if (!ourRequestEvent) {
            throw new Error("Could not find 'RequestStart' event from Router.");
        }

        const { requestId } = ourRequestEvent.args;

        const expectedRequestId = requestIdPacked(subscriptionId, 1);
        if (requestId === expectedRequestId) {
            console.log(`   ‚úÖ Request ID matches expected value derived from requestIdPacked.`);
        } else {
            console.warn(`   ‚ö†Ô∏è Warning: Request ID (${requestId}) does not match expected value (${expectedRequestId}).`);
        }


        console.log(`   ‚úÖ Compute requested successfully!`);
        console.log(`   Request ID: ${requestId}`);

        // --- 3. Wait for the result and verify settlement ---
        console.log("\n3Ô∏è‚É£  Waiting for the node to fulfill the request and receive the result...");

        const clientWalletBalanceBefore = await provider.getBalance(newWalletAddress);

        let lastOutput = "0x";
        const pollInterval = 2000; // 2 seconds
        const maxAttempts = 15; // 30 seconds timeout
        for (let i = 0; i < maxAttempts; i++) {
            lastOutput = await clientContract.lastReceivedOutput();
            if (lastOutput !== "0x" && lastOutput !== null) {
                console.log(`   ‚úÖ Result received in client contract!`);
                console.log(`      Output: ${lastOutput}`);
                break;
            }
            console.log(`   ...waiting (${i + 1}/${maxAttempts})`);
            await new Promise(resolve => setTimeout(resolve, pollInterval));
        }

        if (lastOutput === "0x" || lastOutput === null) {
            throw new Error("Timeout: Did not receive compute result in time.");
        }

        // --- 4. Verify settlement by checking the client's wallet balance ---
        console.log("\n4Ô∏è‚É£  Verifying settlement from client's perspective...");

        // Wait a moment for the settlement transaction to be fully processed
        await new Promise(resolve => setTimeout(resolve, 2000)); // Increased delay for stability
        const clientWalletBalanceAfter = await provider.getBalance(newWalletAddress);

        console.log(`   Client Wallet Balance: ${ethers.formatEther(clientWalletBalanceBefore)} -> ${ethers.formatEther(clientWalletBalanceAfter)} ETH`);

        if (clientWalletBalanceAfter < clientWalletBalanceBefore) {
            console.log("   ‚úÖ Payment sent successfully! Client's wallet balance has decreased.");
        } else {
            console.warn("   ‚ö†Ô∏è Settlement verification inconclusive. Client's wallet balance did not decrease as expected.");
        }

        console.log("\nüéâ E2E test completed successfully!");
        process.exit(0);

    } catch (error) {
        console.error("\nAn error occurred during the client test script:");
        if (error.reason) {
            console.error(`   Reason: ${error.reason}`);
        }
        console.error(error);
        process.exit(1);
    }
}

main();
