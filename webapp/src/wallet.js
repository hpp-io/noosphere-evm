// Use the 'dotenv' package to load environment variables from a .env file.
// To ensure the path is correct regardless of where the script is run from, resolve it from the current directory.
const path = require('path');
require('dotenv').config({ path: path.resolve(__dirname, '../../.env') });

const ethers = require('ethers');

// --- Corrected Path Resolution ---
// Define the project's root directory to resolve all paths correctly.
const projectRoot = path.resolve(__dirname, '../..');

// Import the contract artifact generated by Foundry using the correct path.
const WalletFactoryArtifact = require(path.join(projectRoot, 'out/WalletFactory.sol/WalletFactory.json'));

// Dynamically load the contract address from the latest deployment.
function getLatestDeploymentAddress(contractName) {
    try {
        // Load the broadcast file which contains the results of the last deployment.
        // NOTE: The chain ID (e.g., 181228) might change. Adjust if you use a different chain.
        const broadcast = require(path.join(projectRoot, 'broadcast/Deploy.sol/31337/run-latest.json'));
        // Find the transaction for the contract deployment.
        const deployment = broadcast.transactions.find(
            (tx) => tx.transactionType === 'CREATE' && tx.contractName === contractName
        );
        return deployment?.contractAddress;
    } catch (e) {
        console.error(`Could not find or parse broadcast file for chain 181228.`, e);
        return undefined;
    }
}

async function main() {
    // Load RPC_URL and PRIVATE_KEY from the .env file.
    const rpcUrl = process.env.RPC_URL;
    const privateKey = process.env.PRIVATE_KEY;

    if (!rpcUrl || !privateKey) {
        console.error("Error: RPC_URL or PRIVATE_KEY is not set in the .env file.");
        process.exit(1);
    }

    // Get the WalletFactory address from the latest deployment run.
    const WALLET_FACTORY_ADDRESS = getLatestDeploymentAddress('WalletFactory');

    if (!WALLET_FACTORY_ADDRESS) {
        console.error("Error: Could not find WalletFactory address in run-latest.json. Please deploy contracts first.");
        process.exit(1);
    }

    // Set up the provider to connect to the Ethereum network.
    const provider = new ethers.JsonRpcProvider(rpcUrl);

    // Create a signer instance from the private key. This account will send the transaction.
    const signer = new ethers.Wallet(privateKey, provider);
    console.log(`Using wallet creator address: ${signer.address}`);

    // Create a contract instance for the WalletFactory.
    const walletFactory = new ethers.Contract(
        WALLET_FACTORY_ADDRESS,
        WalletFactoryArtifact.abi, // Use the ABI from the build artifact.
        signer
    );

    // --- VIEW FUNCTION CALL TO VERIFY CONNECTION ---
    try {
        const version = await walletFactory.typeAndVersion();
        console.log(`\n✅ Successfully connected to contract.`);
        console.log(`   Contract: WalletFactory`);
        console.log(`   Address:  ${await walletFactory.getAddress()}`);
        console.log(`   Version:  ${version}`);
    } catch (e) {
        console.error("\n❌ Could not connect to the WalletFactory contract. Please check the address, ABI, and network.");
        console.error(e); // Print the actual error for more details
        process.exit(1);
    }

    console.log("\nSending transaction to create a new wallet...");

    try {
        // The createWallet function in WalletFactory.sol requires an 'initialOwner'.
        // We will use the signer's address as the initial owner for the new wallet.
        const initialOwner = signer.address;
        console.log(`Creating a new wallet for owner: ${initialOwner}`);

        // Call the 'createWallet' function and send the transaction.
        const tx = await walletFactory.createWallet(initialOwner);

        console.log(`Transaction sent! Hash: ${tx.hash}`);
        console.log("Waiting for transaction to be mined...");

        // Wait for the transaction to be included in a block.
        const receipt = await tx.wait(1);

        // IMPORTANT: Check if the transaction was actually successful.
        if (receipt.status !== 1) {
            console.error(`\n❌ Transaction failed! Receipt status: ${receipt.status}`);
            console.error("The transaction was mined but reverted. No events were emitted.");
            process.exit(1);
        }

        console.log("Transaction mined successfully! (status: 1)");

        // The most robust way to find an event in ethers v6.
        // It filters events by contract, event name, and within a specific block range.
        // We add a filter for the 'operator' argument to find only the event from our transaction.
        const eventFilter = walletFactory.filters.WalletCreated(signer.address);
        const events = await walletFactory.queryFilter(eventFilter, receipt.blockNumber, receipt.blockNumber);

        // Find the specific event from our transaction hash within the filtered events.
        const walletCreatedEvent = events.find(e => e.transactionHash === tx.hash);

        if (walletCreatedEvent) {
            const { operator, owner, walletAddress } = walletCreatedEvent.args;
            console.log("\n✅ New Wallet Created!");
            console.log(`   Operator (tx sender): ${operator}`);
            console.log(`   Initial Owner:        ${owner}`);
            console.log(`   New Wallet Address:   ${walletAddress}`);
        } else {
            console.error("Could not find 'WalletCreated' event in the transaction receipt.");
            console.error("Please check the WalletFactory contract and transaction details.");
        }

    } catch (error) {
        console.error("\nAn error occurred during wallet creation:");
        // Ethers.js often provides a 'reason' for the failure.
        if (error.reason) {
            console.error(`Reason: ${error.reason}`);
        }
        console.error(error);
        process.exit(1);
    }
}

main();